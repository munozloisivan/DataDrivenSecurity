---
title: "Proyecto Data Driven Security"
author: "Ivan Muñoz Lois, Stela-Mihaela Chioveanu "
output: html_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(readr)
library(ggplot2)
library(dplyr)
```

### 1.1 Carga del archivo con la fuente de datos

Primero de todo, cargamos el archivo que contiene las vulnerabilidades encontradas tras realizar un scan con Qualys

```{r, warning=FALSE, message=FALSE, echo=FALSE}
inputReportDf <- read_csv("C:/Users/ivanm/Desktop/Master/5. Data Driven Security/Scan_Results_abtes2vm_20191217_scan_1574870445_41138.csv",
skip = 6)
```

### 1.2 Filtrado del dataframe

Una vez tenemos nuestro dataframe, procedemos a filtrar para quedarnos únicamente con aquellos datos que serán relevantes para nuestro caso de estudio.

```{r, warning=FALSE}
mydf <- inputReportDf[,c("IP", "QID", "Type", "Severity", "CVE ID")]
```

Nos hemos quedado con los siguientes campos:

```{r, warning=FALSE, echo=FALSE}
colnames(mydf)
```
Podemos observar un ejemplo de estos datos:

```{r, warning=FALSE, echo=FALSE}
library(kableExtra)
kable(head(mydf,5), align=rep('c', 5)) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

De la siguiente manera se puede construir un dataframe en el que tratar después cada tipo de dato como sea necesario por coerción

```{r, warning=FALSE}
a1 <- inputReportDf[,c("IP")]
b2 <- inputReportDf[,c("QID")]
c3 <- inputReportDf[,c("Type")]
d4 <- inputReportDf[,c("Severity")]
e5 <- inputReportDf[,c("CVE ID")]

test <- data.frame(a1,b2,c3,d4,e5, stringsAsFactors = F)
```

### 1.3 Clasificamos en una tabla los tipos de vulnerabilidad y severidad, así como un contador que indica cuantos casos se han identificado

```{r, warning=FALSE}
plotableType <- as.data.frame((table(test$Type, test$Severity)))
colnames(plotableType) <- c("Type", "Severity", "Count")
```
Veamos la tabla que obtenemos, para poder entender la gráfica que vendrá a continuación:

```{r, warning=FALSE, echo=FALSE}
library(kableExtra)
#head(plotableType)
#knitr::kable(plotableType, align = 'c')
kable(plotableType, align=rep('c', 3)) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

### 1.4 Mostramos un gráfico que representa los valores de la tabla

```{r, fig.align='center', warning=FALSE, echo=FALSE}
plot1 <- ggplot(plotableType, aes(x=Type, y=Count)) + geom_bar(stat = "identity")

plot(plot1)
```

### 1.5 Mostramos un gráfico que representa el total de vulns encontradas en función de su tipo y severidad
```{r, fig.align='center', warning=FALSE, echo=FALSE}
plot2 <- ggplot(plotableType, aes(x=Count, y=Severity)) + geom_point(aes(colour= factor(Type))) + scale_colour_manual(values = c("red", "blue", "green"))

plot(plot2)
```

## 2. Relación de los datos obtenidos en el scan de Qualys con información disponible en la Knowledge Base

Cargamos el fichero que contiene la información de la Knowledge Base de Qualys en un dataframe

```{r, warning=FALSE, message=FALSE, echo=FALSE}
KnowledgeBaseDfPOC <- read_csv("C:/Users/ivanm/Desktop/Master/5. Data Driven Security/DL_vulnerabilities_abtes2vm_20191217.csv", skip = 3)
```

### 2.1 Filtrado del dataframe

Una vez tenemos nuestro dataframe, procedemos a filtrar para quedarnos únicamente con aquellos datos que serán relevantes las relaciones que nos interesan realizar.

```{r, warning=FALSE}
KDB_dfPOC <- KnowledgeBaseDfPOC[,c("QID", "Category", "Modified", "Published", "CVSS Base", "CVE ID")]
```

```{r, warning=FALSE, echo=FALSE}
#Eliminar aquellos que no tengan valor CVSS
KDB_dfPOC_clean <- filter(KDB_dfPOC, KDB_dfPOC$`CVSS Base` != '\'-')
```
Nos quedamos con los siguientes campos:

```{r, warning=FALSE, echo=FALSE}
colnames(KDB_dfPOC)
```

### 2.2 Juntamos ambos input (El scan de Qualys y la Knowlegdge Base) en un mismo dataframe 
Los relacionamos por la columna QID que es común en ambos datos y nos permitirá poder relacionarlos correctamente.

```{r, warning=FALSE, echo=FALSE}
dfPOC <- merge(test, KDB_dfPOC_clean, by ="QID")
```

Filtramos de nuevo, dado que existen algunas columnas como CVE ID que están duplicadas (ambos dataframes la contenian por igual)
```{r, warning=FALSE, echo=FALSE}
dfPOC <- dfPOC[,c("QID", "IP", "Type", "Severity", "CVSS Base", "CVE ID")]
```
Nos queda finalmente un dataframe con los siguientes campos:
```{r, warning=FALSE, echo=FALSE}
colnames(dfPOC)
```

### 2.3 Creamos una tabla que clasifica por tipo, CVSS y un contador
```{r, warning=FALSE, echo=FALSE}
plotTablePOC <- as.data.frame((table(dfPOC$Type, dfPOC$`CVSS Base`)))
#Asignamos nombres a cada columna de la tabla
colnames(plotTablePOC) <- c("Type", "CVSS Base", "Count")
```

```{r, warning=FALSE, echo=FALSE}
library(kableExtra)
kable(plotTablePOC, align=rep('c', 3)) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

### 2.4 Mostramos un gráfico que representa el número de vulnerabilidades encontradas y su CVSS según la Knowledge Base de Qualys
```{r, fig.align='center', warning=FALSE, echo=FALSE}
plot1POC <- ggplot(plotTablePOC, aes(x=Count, y=`CVSS Base`)) + geom_point(aes(colour= Type)) + scale_colour_manual(values = c("green", "blue", "red"))
plot(plot1POC)
```

